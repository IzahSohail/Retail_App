generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/*
  Core application models (unchanged structure except where noted)
*/

model User {
  id                    String                  @id @default(cuid())
  email                 String                  @unique
  name                  String?
  auth0Id               String?                 @unique
  picture               String?
  gender                String?
  dateOfBirth           DateTime?
  role                  UserRole                @default(USER)
  lastLogin             DateTime?
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  phoneNumber           String?
  studentId             String?
  university            String?
  isVerified            Boolean                 @default(false)
  // Store credit balance (in minor units, e.g., cents)
  creditMinor           Int                     @default(0)
  sales                 Sale[]                  @relation("BuyerSales")
  products              Product[]               @relation("SellerProducts")
  cart                  Cart?
  b2b                   B2B?
  verification_requests verification_requests[]
  // New: return requests submitted by this user
  returnRequests        ReturnRequest[]         @relation("UserReturnRequests")
  // New: inspections performed by this user
  inspections           Inspection[]
  // New: audit logs for actions by this user
  auditLogs             RmaAuditLog[]

  @@map("users")
}

model Category {
  id        String    @id @default(cuid())
  name      String    @unique
  slug      String    @unique
  createdAt DateTime  @default(now())
  products  Product[]

  @@map("categories")
}

model Product {
  id             String          @id @default(cuid())
  title          String
  description    String
  priceMinor     Int
  currency       String          @default("AED")
  stock          Int
  active         Boolean         @default(true)
  categoryId     String
  sellerId       String
  imageUrl       String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  category       Category        @relation(fields: [categoryId], references: [id])
  seller         User            @relation("SellerProducts", fields: [sellerId], references: [id])
  saleItems      SaleItem[]
  cartItems      CartItem[]
  flashSaleItems FlashSaleItem[]
  defectiveItems DefectiveItems[]

  @@index([categoryId])
  @@index([sellerId])
  @@index([active, createdAt])
  @@map("products")
}

model Sale {
  id                     String     @id @default(cuid())
  buyerId                String
  status                 SaleStatus @default(PENDING)
  subtotalMinor          Int
  taxMinor               Int        @default(0)
  feesMinor              Int        @default(0)
  totalMinor             Int
  currency               String     @default("AED")
  idempotencyKey         String?    @unique
  createdAt              DateTime   @default(now())
  completedAt            DateTime?
  payment                Payment?
  buyer                  User       @relation("BuyerSales", fields: [buyerId], references: [id], onDelete: Cascade)
  items                  SaleItem[]
  // New: Return requests (RMA) associated with this sale
  rmas                   ReturnRequest[] @relation("SaleRmas")
  // Optional denormalized field, helpful for fast reads (sum of refunds in minor units)
  refundedMinorTotal     Int?       @default(0)

  @@index([buyerId, status])
  @@index([createdAt])
  @@index([idempotencyKey])
  @@map("sales")
}

model SaleItem {
  id             String  @id @default(cuid())
  saleId         String
  productId      String
  quantity       Int
  unitMinor      Int
  lineTotalMinor Int
  product        Product @relation(fields: [productId], references: [id])
  sale           Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)
  // New: return items that map back to this sale item
  returnItems    ReturnItem[]

  @@index([saleId])
  @@index([productId])
  @@map("sale_items")
}

model Payment {
  id            String        @id @default(cuid())
  saleId        String        @unique
  method        PaymentMethod
  status        PaymentStatus
  approvalRef   String?
  failureReason String?
  createdAt     DateTime      @default(now())
  sale          Sale          @relation(fields: [saleId], references: [id], onDelete: Cascade)
  // New: refunds issued against this payment (if any)
  refunds       Refund[]

  @@map("payments")
}

enum PaymentMethod {
  CASH
  CARD
  STORE_CREDIT
}

enum PaymentStatus {
  APPROVED
  DECLINED
  // Refund-related additive values
  REFUNDED
  PARTIALLY_REFUNDED
}

enum SaleStatus {
  PENDING
  COMPLETED
  CANCELED
  // Refund workflow statuses (additive)
  REFUND_PENDING
  REFUNDED
}

/*
  Cart models (unchanged)
*/
model Cart {
  id        String     @id @default(cuid())
  userId    String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]

  @@map("carts")
}

model CartItem {
  id        String   @id @default(cuid())
  cartId    String
  productId String
  quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  cart      Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product   Product  @relation(fields: [productId], references: [id])

  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
  @@map("cart_items")
}

/*
  B2B & verification (unchanged)
*/
model B2B {
  id                   String    @id @default(cuid())
  userId               String    @unique
  businessName         String?
  businessDescription  String?
  registeredAddress    String?
  tradeLicenseUrl      String?
  establishmentCardUrl String?
  status               B2BStatus @default(PENDING)
  rejectionReason      String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("b2b")
}

enum UserRole {
  USER
  BUSINESS
  ADMIN
}

enum B2BStatus {
  PENDING
  UNDER_REVIEW
  VERIFIED
  REJECTED
}

model verification_requests {
  id              String    @id @default(cuid())
  userId          String
  status          String    @default("pending")
  studentId       String
  university      String
  phoneNumber     String?
  additionalInfo  String?
  submittedAt     DateTime  @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?
  rejectionReason String?
  users           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verification_requests")
}

/*
  Flash sales (unchanged)
*/
enum DiscountType {
  PERCENTAGE
  FIXED
}

model FlashSale {
  id            String        @id @default(cuid())
  title         String
  description   String?
  discountType  DiscountType
  discountValue Int
  startsAt      DateTime
  endsAt        DateTime
  priority      Int           @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  items         FlashSaleItem[]

  @@map("flash_sales")
}

model FlashSaleItem {
  id          String    @id @default(cuid())
  flashSaleId String
  productId   String
  flashSale   FlashSale @relation(fields: [flashSaleId], references: [id], onDelete: Cascade)
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([flashSaleId, productId])
  @@map("flash_sale_items")
}

/*
  NEW: Returns & Refunds workflow models
*/

enum RmaStatus {
  INSPECTION              // Auto-set when user submits
  APPROVED_AWAITING_SHIPMENT  // Admin approved, waiting for user to ship
  REJECTED                // Admin rejected
  SHIPPED                 // User has shipped the item back
  COMPLETED               // Admin confirmed receipt, refund issued
  CLOSED                  // Case closed/archived
}

enum InspectionResult {
  PASS
  FAIL
  INCONCLUSIVE
}

enum RefundMethod {
  ORIGINAL_PAYMENT
  STORE_CREDIT
  MANUAL
}

model ReturnRequest {
  id              String       @id @default(cuid())
  rmaNumber       String       @unique
  saleId          String
  userId          String
  status          RmaStatus    @default(INSPECTION)
  reason          String       @default("")
  details         String       @default("")
  photoUrls       String[]     // Array of Supabase URLs for uploaded photos
  // Links
  sale            Sale         @relation("SaleRmas", fields: [saleId], references: [id], onDelete: Cascade)
  user            User         @relation("UserReturnRequests", fields: [userId], references: [id], onDelete: Cascade)
  items           ReturnItem[]
  shipments       ReturnShipment[]
  inspections     Inspection[]
  refunds         Refund[]
  auditLogs       RmaAuditLog[]
  defectiveItems  DefectiveItems[] @relation("ReturnDefectiveItems")
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  completedAt     DateTime?    // Track completion date for cycle time metrics
  // When store-credit was issued to the user's account for this RMA
  creditIssuedAt  DateTime?

  @@index([saleId])
  @@index([userId])
  @@index([status])
  @@map("return_requests")
}

model ReturnItem {
  id               String     @id @default(cuid())
  returnRequestId  String
  // Optional link back to the original sale item (snapshot of what was purchased)
  saleItemId       String?
  quantity         Int
  conditionNotes   String    @default("")
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  saleItem         SaleItem?     @relation(fields: [saleItemId], references: [id])

  @@index([returnRequestId])
  @@index([saleItemId])
  @@map("return_items")
}

model ReturnShipment {
  id               String     @id @default(cuid())
  returnRequestId  String
  carrier          String     @default("")
  trackingNumber   String     @default("")
  shippedAt        DateTime?
  receivedAt       DateTime?
  labelUrl         String     @default("")
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)

  @@index([returnRequestId])
  @@map("return_shipments")
}

model Inspection {
  id               String           @id @default(cuid())
  returnRequestId  String
  inspectorId      String?          // optional link to user who inspected
  result           InspectionResult
  notes            String           @default("")
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  returnRequest    ReturnRequest    @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  inspector        User?            @relation(fields: [inspectorId], references: [id])

  @@index([returnRequestId])
  @@map("inspections")
}

model Refund {
  id               String      @id @default(cuid())
  returnRequestId  String
  // optional payment reference (if refund is routed back to a payment record)
  paymentId        String?     
  method           RefundMethod
  amountMinor      Int
  currency         String      @default("AED")
  reason           String      @default("")
  refundRef        String      @default("")     
  status           PaymentStatus
  processedAt      DateTime?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  payment          Payment?      @relation(fields: [paymentId], references: [id])

  @@index([returnRequestId])
  @@index([paymentId])
  @@map("refunds")
}

model RmaAuditLog {
  id               String     @id @default(cuid())
  returnRequestId  String
  actorId          String?    // user or system actor
  action           String
  message          String     @default("")
  createdAt        DateTime   @default(now())

  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  actor            User?         @relation(fields: [actorId], references: [id])

  @@index([returnRequestId])
  @@map("rma_audit_logs")
}

model DefectiveItems {
  id               String        @id @default(cuid())
  returnRequestId  String
  productId        String
  stock            Int
 
  returnRequest    ReturnRequest @relation("ReturnDefectiveItems", fields: [returnRequestId], references: [id], onDelete: Cascade)
  product          Product       @relation(fields: [productId], references: [id])
 
  @@index([returnRequestId])
  @@index([productId])
  @@unique([returnRequestId, productId])
  @@map("defective_items")
}